---
title: 面试题整理
date: 2020-03-03 09:24:29
tags: 面试
categories: 工作
---



# Java

***

## Java基础

***

### 面向对象的特征

#### 封装

是把客观事物封装成抽象的类，把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口，只让可信的类或者对象操作，对不可信的进行信息隐藏。

#### 继承

它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。子类继承父类，从而继承了父类的方法和属性。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。

#### 多态

多态性是指允许不同类的对象对同一消息作出响应，即同一消息可以根据 发送对象的不同而采用多种不同的行为方式。

##### 多态的三个必要条件

- 要有继承
- 要有方法的重写
- 父类引用指向子类对象

##### 多态的优点

- 可替换性
- 可扩充性

#### 抽象

抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

***

### 重载和重写的区别

#### 重载  Overload

发生在同一个类中，方法名相同，具有不同的参数个数或不同的参数类型，方法返回值和访问修饰符可以不同。重载其实本质上就是完全不同的方法，只是恰好取了相同的名字。

#### 重写  Override

发生在父子类中，方法名、参数列表相同，返回值范围小于等于父类，抛出的异常范围小于等于父类， 访问修饰符范围大于等于父类。

***

### 关于final关键字

#### 变量

- 如果是基本数据类型的变量，修饰的变量初始化后不可以被改变。
- 如果是引用类型的变量，修饰的引用初始化之后便不能再让其指向另一个对象,引用指向的内容可变。

#### 方法

修饰的方法不可以被重写。

#### 类

修饰的类不可以被继承，类中的所有成员方法都会被隐式地指定为 final 方法。

***

### String、StringBuffer 和 StringBuilder 的区别

| 关键字        | 类型       | 线程安全   | 可变   | 性能 | 新增                   |
| ------------- | ---------- | ---------- | ------ | ---- | ---------------------- |
| String        | 字符串常量 | 线程安全   | 不可变 | 3    | 创建一个新的String对象 |
| StringBuffer  | 字符串常量 | 线程安全   | 可变   | 2    | 本身进行操作           |
| StringBuilder | 字符串常量 | 非线程安全 | 可变   | 1    | 本身进行操作           |

AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，底层实现上的话，StringBuffer 其实就是比 StringBuilder 多了 Synchronized 修饰符。

***

### equals 与 == 的区别

#### ==

它的作用是判断两个对象的内存地址是不是相等，判断两个对象是不是同一个对象。基本数据类型 ``==`` 比较的是值，引用数据类型 ``==`` 比较的是内存地址。

#### equals()

它的作用也是判断两个对象是否相等，但是分为两种情况：

- 情况1：类没有覆盖 equals 方法。则通过 equals 比较该类的两个对象时，等价于 ``==`` 比较这两个对象。
- 情况2：类覆盖了 equals 方法。一般，我们都覆盖 equals 方法来比较两个对象的内容相等，若它们的内容相等，则返回 true。

String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

***

### Java异常

{% asset_img Exception.png Exception %}

在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。

Throwable 有两个重要的子类：**Exception（异常）** 和 **Error（错误）** ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。



## Java集合框架

***

{% asset_img Collection.png Collection %}

{% asset_img Map.png Map %}

***

## Java虚拟机

***

关于关于Java虚拟机，在面试的时候一般会问的大多是

- Java内存区域
- 虚拟机垃圾算法
- 虚拟机垃圾收集器
- JVM内存管理
- JVM调优
- Java类加载机制

***

### Java内存区域

#### 基本问题

- 介绍下 Java 内存区域（运行时数据区）
- Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
- 对象的访问定位的两种方式（句柄和直接指针两种方式）

***

### JVM垃圾回收

***

#### 基本问题

- 如何判断对象是否死亡（两种方法）
- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）
- 如何判断一个常量是废弃常量
- 如何判断一个类是无用的类
- 垃圾收集有哪些算法，各自的特点？
- HotSpot 为什么要分为新生代和老年代？
- 常见的垃圾回收器有哪些？
- 介绍一下 CMS,G1 收集器
- Minor Gc 和 Full GC 有什么不同呢？

***

#### 思路线索

{% asset_img JVM GC.jpg JVM垃圾回收 %}

当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

***

#### 如何判断对象是否死亡

***

# 计算机网络

***

## 各层结构与作用

{% asset_img TCPIP.png 各层结构 %}

- 应用层的任务是通过应用进程间的交互来完成特定网络应用。
- 运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。
- 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。
- 数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。
- 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

***

## TCP、UDP 协议的区别

{% asset_img TCP-UDP.jpg TCP-UDP区别 %}

- TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），难以避免增加了许多开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。
- UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如 QQ 语音、 QQ 视频 、直播等等。

***

## url 地址到显示网页的过程

{% asset_img url.jpg url 地址到显示网页的过程 %}

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

***

## TCP 三次握手和四次挥手

### 三次握手

{% asset_img Three-way.png TCP 三次握手 %}

{% asset_img Three-way 2.png TCP 三次握手 %}

连通一个 TCP 连接则需要“三次握手”：

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

### 为什么要三次握手

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；
                          Server 确认了：自己接收正常，对方发送正常
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；
                          Server 确认了：自己发送、接收正常， 对方发送接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

### 为什么要传回 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

### 传了 SYN,为什么还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

### 四次挥手

{% asset_img Four-way.png TCP 四次挥手 %}

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送。
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号。
- 服务器-关闭与客户端的连接，发送一个FIN给客户端。
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1。

### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

***

# 操作系统

## Linux

***

### 简单介绍一下 Linux 文件系统

#### Linux文件系统简介

在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 

也就是说在 LINUX 系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而 Linux 是重写 UNIX 而来，所以这个概念也就传承了下来。在 UNIX 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。

##### 文件类型与目录结构

###### Linux支持5种文件类型 

{% asset_img Linux.jpg Linux支持5种文件类型 %}

###### Linux的目录结构

{% asset_img root.jpg Linux的目录结构 %}

常见目录说明：

- **/bin：** 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里。
- **/etc：** 存放系统管理和配置文件。
- **/home：** 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。
- **/usr ：** 用于存放系统应用程序。
- **/opt：** 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。
- **/proc：** 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
- **/root：** 超级用户（系统管理员）的主目录（特权阶级）。
- **/sbin:** 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序，如ifconfig等。
- **/dev：** 用于存放设备文件。
- **/mnt：** 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。
- **/boot：** 存放用于系统引导时使用的各种文件。
- **/lib ：** 存放着和系统运行相关的库文件 。
- **/tmp：** 用于存放各种临时文件，是公用的临时文件存储点。
- **/var：** 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志）等。
- **/lost+found：** 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫 .chk）就在这里。

***

### 一些常见的 Linux 命令

#### 目录切换命令

- **`cd usr`：** 切换到该目录下usr目录
- **`cd ..（或cd../）`：** 切换到上一层目录
- **`cd /`：** 切换到系统根目录
- **`cd ~`：** 切换到用户主目录
- **`cd -`：** 切换到上一个操作所在目录

#### 目录的操作命令（增删改查）

- **`mkdir 目录名称`：** 增加目录

- **`ls或者ll`**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息

- **`find 目录 参数`：** 寻找目录（查）

- **`mv 目录名称 新目录名称`：** 修改目录的名称（改）

  注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。

- **`mv 目录名称 目录的新位置`：** 移动目录的位置---剪切（改）

  注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。

- **`cp -r 目录名称 目录拷贝的目标位置`：** 拷贝目录（改），-r代表递归拷贝

  注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写 -r 递归。

- **`rm [-rf] 目录`:** 删除目录（删）

  注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用 `rm -rf` 目录/文件/压缩包。

#### 文件的操作命令（增删改查）

- **`touch 文件名称`:** 文件的创建（增）

- **`cat/more/less/tail 文件名称`** 文件的查看（查）

  - **`cat`：** 查看显示文件内容
  - **`more`：** 可以显示百分比，回车可以向下一行， 空格可以向下一页，q 可以退出查看
  - **`less`：** 可以使用键盘上的 PgUp 和 PgDn 向上 和向下翻页，q 结束查看
  - **`tail-10` ：** 查看文件的后10行，Ctrl+C 结束

  注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 tail -f catalina-2016-11-11.log 监控文件的变化。

- **`vim 文件`：** 修改文件的内容（改）

  vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。

  

  在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：

  1. vim 文件
  2. 进入文件
  3. 命令模式
  4. 按i进入编辑模式
  5. 编辑文件
  6. 按Esc进入底行模式
  7. 输入：wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q! 代表强制退出不保存。）

- **`rm -rf 文件`：** 删除文件（删）

  同目录删除：熟记 `rm -rf` 文件 即可

#### 压缩文件的操作命令

##### 打包并压缩文件

Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。

而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：**`tar -zcvf 打包压缩后的文件名 要打包压缩的文件`** 其中：

z：调用gzip压缩命令进行压缩

c：打包文件

v：显示运行过程

f：指定文件名

比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：**`tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt`或：`tar -zcvf test.tar.gz /test/`**

##### 解压压缩包

命令：tar [-xvf] 压缩文件

其中：x：代表解压

示例：

1 将/test下的test.tar.gz解压到当前目录下可以使用命令：**`tar -xvf test.tar.gz`**

2 将/test下的test.tar.gz解压到根目录/usr下:**`tar -xvf test.tar.gz -C /usr`**（- C代表指定解压的位置）



#### 其他常用命令

- **`pwd`：** 显示当前所在位置

- **`sudo + 其他命令`**：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。

- **`grep 要搜索的字符串 要搜索的文件 --color`：** 搜索命令，--color代表高亮显示

- **`ps -ef`/`ps -aux`：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**`ps aux|grep redis`** （查看包括redis字符串的进程），也可使用 `pgrep redis -a`。

  注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。

- **`kill -9 进程的pid`：** 杀死进程（-9 表示强制终止。）

  先用ps查找进程，然后用kill杀掉

- **网络通信命令：**

  - 查看当前系统的网卡信息：ifconfig
  - 查看与某台机器的连接情况：ping
  - 查看当前系统的端口使用：netstat -an

- **net-tools 和 iproute2 ：** `net-tools`起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持`iproute2`。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读[如何在Linux中使用IP命令和示例](https://linoxide.com/linux-command/use-ip-command-linux)

- **`shutdown`：** `shutdown -h now`： 指定现在立即关机；`shutdown +5 "System will shutdown after 5 minutes"`：指定5分钟后关机，同时送出警告信息给登入用户。

- **`reboot`：** **`reboot`：** 重开机。**`reboot -w`：** 做个重开机的模拟（只有纪录并不会真的重开机）。