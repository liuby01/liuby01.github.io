<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JavaJava基础 面向对象的特征封装是把客观事物封装成抽象的类，把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口，只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。子类继承父类，从而继承了父类的方法和属性。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。 多态多">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="live in 2077">
<meta property="og:description" content="JavaJava基础 面向对象的特征封装是把客观事物封装成抽象的类，把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口，只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。子类继承父类，从而继承了父类的方法和属性。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。 多态多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Exception.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Collection.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Map.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/TCPIP.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/TCP-UDP.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/url.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Three-way.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Four-way.png">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/root.jpg">
<meta property="article:published_time" content="2020-03-03T01:24:29.000Z">
<meta property="article:modified_time" content="2020-05-02T16:53:11.679Z">
<meta property="article:author" content="liuby">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Exception.png">

<link rel="canonical" href="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>面试题 | live in 2077</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">live in 2077</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liuby">
      <meta itemprop="description" content="操千曲而后晓声，观千剑而后识器。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="live in 2077">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-03 09:24:29" itemprop="dateCreated datePublished" datetime="2020-03-03T09:24:29+08:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-03 00:53:11" itemprop="dateModified" datetime="2020-05-03T00:53:11+08:00">2020-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index">
                    <span itemprop="name">工作</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><hr>
<h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>是把客观事物封装成抽象的类，把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口，只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。子类继承父类，从而继承了父类的方法和属性。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态性是指允许不同类的对象对同一消息作出响应，即同一消息可以根据 发送对象的不同而采用多种不同的行为方式。</p>
<h5 id="多态的三个必要条件"><a href="#多态的三个必要条件" class="headerlink" title="多态的三个必要条件"></a>多态的三个必要条件</h5><ul>
<li>要有继承</li>
<li>要有方法的重写</li>
<li>父类引用指向子类对象</li>
</ul>
<h5 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h5><ul>
<li>可替换性</li>
<li>可扩充性</li>
</ul>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<hr>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><h4 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载  Overload"></a>重载  Overload</h4><p>发生在同一个类中，方法名相同，具有不同的参数个数或不同的参数类型，方法返回值和访问修饰符可以不同。重载其实本质上就是完全不同的方法，只是恰好取了相同的名字。</p>
<h4 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写  Override"></a>重写  Override</h4><p>发生在父子类中，方法名、参数列表相同，返回值范围小于等于父类，抛出的异常范围小于等于父类， 访问修饰符范围大于等于父类。</p>
<hr>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现。</td>
<td>接口完全是抽象的，它根本不存在方法的实现。</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字 implements 来实现接口，它需要提供接口中所有声明的方法的实现。</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器。</td>
<td>接口不能有构造器。</td>
</tr>
<tr>
<td>与正常 Java 类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别。</td>
<td>接口是完全不同的类型。</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有 public、protected 和 default 这些修饰符。</td>
<td>接口方法默认修饰符是 public，你不可以使用其它修饰符。接口中的实例变量默认是 final 类型的。</td>
</tr>
<tr>
<td>main 方法</td>
<td>抽象方法可以有 main 方法并且我们可以运行它。</td>
<td>接口没有 main 方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口。</td>
<td>接口可以通过 extends 关键字扩展多个接口。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现，因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>从设计层面来说，抽象是对类的抽 象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<hr>
<h3 id="关于final关键字"><a href="#关于final关键字" class="headerlink" title="关于final关键字"></a>关于final关键字</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>如果是基本数据类型的变量，修饰的变量初始化后不可以被改变。</li>
<li>如果是引用类型的变量，修饰的引用初始化之后便不能再让其指向另一个对象,引用指向的内容可变。</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>修饰的方法不可以被重写。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>修饰的类不可以被继承，类中的所有成员方法都会被隐式地指定为 final 方法。</p>
<hr>
<h3 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a>String、StringBuffer 和 StringBuilder 的区别</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>类型</th>
<th>线程安全</th>
<th>可变</th>
<th>性能</th>
<th>新增</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串常量</td>
<td>线程安全</td>
<td>不可变</td>
<td>3</td>
<td>创建一个新的String对象</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>字符串常量</td>
<td>线程安全</td>
<td>可变</td>
<td>2</td>
<td>本身进行操作</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>字符串常量</td>
<td>非线程安全</td>
<td>可变</td>
<td>1</td>
<td>本身进行操作</td>
</tr>
</tbody></table>
<p>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，底层实现上的话，StringBuffer 其实就是比 StringBuilder 多了 Synchronized 修饰符。</p>
<hr>
<h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h3><h4 id=""><a href="#" class="headerlink" title="=="></a>==</h4><p>它的作用是判断两个对象的内存地址是不是相等，判断两个对象是不是同一个对象。基本数据类型 <code>==</code> 比较的是值，引用数据类型 <code>==</code> 比较的是内存地址。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>它的作用也是判断两个对象是否相等，但是分为两种情况：</p>
<ul>
<li>情况1：类没有覆盖 equals 方法。则通过 equals 比较该类的两个对象时，等价于 <code>==</code> 比较这两个对象。</li>
<li>情况2：类覆盖了 equals 方法。一般，我们都覆盖 equals 方法来比较两个对象的内容相等，若它们的内容相等，则返回 true。</li>
</ul>
<p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p>
<hr>
<h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Exception.png" class="" title="Exception">

<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。</p>
<p>Throwable 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p>异常和错误的区别：异常能被程序本身处理，错误无法处理。</p>
<h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>是程序无法处理的错误，表示运行应用程序中较严重问题。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
<h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>Exception（异常）:是程序本身可以处理的异常。Exception 可以分为可查异常（一般异常）（checked exceptions）和非可查异常（运行时异常）（unchecked exceptions）。</p>
<p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h5 id="一般异常"><a href="#一般异常" class="headerlink" title="一般异常"></a>一般异常</h5><p>都是 RuntimeException 类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常。</p>
<h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个 异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p>
<ul>
<li>try ：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch ：用于处理 try 捕获到的异常。</li>
<li>finally ：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
<li>throw：throw 语句用在方法体内，throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。</li>
<li>throws：throws 语句是用在方法声明后面，throws 表示出现异常的一种可能性，并不一定会发生这种异常。</li>
</ul>
<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><hr>
<img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Collection.png" class="" title="Collection">

<h3 id="List-和-Set"><a href="#List-和-Set" class="headerlink" title="List 和 Set"></a>List 和 Set</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">Set</th>
</tr>
</thead>
<tbody><tr>
<td align="center">放入顺序</td>
<td align="center">有放入顺序</td>
<td align="center">无放入顺序</td>
</tr>
<tr>
<td align="center">元素重复</td>
<td align="center">元素可重复</td>
<td align="center">元素不可重复</td>
</tr>
</tbody></table>
<h4 id="Arraylist、Vector-与-LinkedList"><a href="#Arraylist、Vector-与-LinkedList" class="headerlink" title="Arraylist、Vector 与 LinkedList"></a>Arraylist、Vector 与 LinkedList</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Arraylist</th>
<th align="center">Vector</th>
<th align="center">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">底层数据结构</td>
<td align="center">Object数组</td>
<td align="center">Object数组</td>
<td align="center">是双向链表</td>
</tr>
<tr>
<td align="center">线程安全</td>
<td align="center">非线程安全</td>
<td align="center">线程安全</td>
<td align="center">非线程安全</td>
</tr>
<tr>
<td align="center">查询效率</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">低</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h5 id="list-的遍历方式选择"><a href="#list-的遍历方式选择" class="headerlink" title="list 的遍历方式选择"></a>list 的遍历方式选择</h5><ul>
<li>实现了 RandomAccess 接口的 list，优先选择普通 for 循环 ，其次 foreach。</li>
<li>未实现 RandomAccess 接口的 list， 优先选择 iterator 遍历（foreach 遍历底层也是通过 iterator 实现的），大 size 的数据，千万不要使用普通 for 循环。</li>
</ul>
<h4 id="HashSet-和-HashMap"><a href="#HashSet-和-HashMap" class="headerlink" title="HashSet 和 HashMap"></a>HashSet 和 HashMap</h4><p>HashSet 底层就是基于 HashMap 实现的。</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 Map 接口</td>
<td align="center">实现 Set 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">HashMap 使用键（Key）计算 hashcode</td>
<td align="center">HashSet 使用成员对象来计算 hashcode 值</td>
</tr>
</tbody></table>
<h5 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h5><p>当你把对象加入 HashSe t时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用<code>equals（）</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
<hr>
<img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Map.png" class="" title="Map">

<hr>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><hr>
<p>关于关于Java虚拟机，在面试的时候一般会问的大多是</p>
<ul>
<li>Java内存区域</li>
<li>虚拟机垃圾算法</li>
<li>虚拟机垃圾收集器</li>
<li>JVM内存管理</li>
<li>JVM调优</li>
<li>Java类加载机制</li>
</ul>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><h4 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h4><ul>
<li>介绍下 Java 内存区域（运行时数据区）</li>
<li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li>
<li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li>
</ul>
<hr>
<h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="基本问题-1"><a href="#基本问题-1" class="headerlink" title="基本问题"></a>基本问题</h4><ul>
<li>如何判断对象是否死亡（两种方法）</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul>
<h4 id="思路线索"><a href="#思路线索" class="headerlink" title="思路线索"></a>思路线索</h4>

<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<h4 id="如何判断对象是否死亡"><a href="#如何判断对象是否死亡" class="headerlink" title="如何判断对象是否死亡"></a>如何判断对象是否死亡</h4><hr>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><hr>
<h2 id="各层结构与作用"><a href="#各层结构与作用" class="headerlink" title="各层结构与作用"></a>各层结构与作用</h2><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/TCPIP.png" class="" title="各层结构">

<ul>
<li>应用层的任务是通过应用进程间的交互来完成特定网络应用。</li>
<li>运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。</li>
<li>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</li>
<li>数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</li>
<li>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
</ul>
<hr>
<h2 id="TCP、UDP-协议的区别"><a href="#TCP、UDP-协议的区别" class="headerlink" title="TCP、UDP 协议的区别"></a>TCP、UDP 协议的区别</h2><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/TCP-UDP.jpg" class="" title="TCP-UDP区别">

<ul>
<li>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），难以避免增加了许多开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li>
<li>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如 QQ 语音、 QQ 视频 、直播等等。</li>
</ul>
<hr>
<h2 id="url-地址到显示网页的过程"><a href="#url-地址到显示网页的过程" class="headerlink" title="url 地址到显示网页的过程"></a>url 地址到显示网页的过程</h2><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/url.jpg" class="" title="url 地址到显示网页的过程">

<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<hr>
<h2 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Three-way.png" class="" title="TCP 三次握手">



<p>连通一个 TCP 连接则需要“三次握手”：</p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ul>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常。</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常。</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常， 对方发送接收正常。</li>
</ul>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<h3 id="传了-SYN-为什么还要传-ACK"><a href="#传了-SYN-为什么还要传-ACK" class="headerlink" title="传了 SYN,为什么还要传 ACK"></a>传了 SYN,为什么还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Four-way.png" class="" title="TCP 四次挥手">

<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送。</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端。</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<hr>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr>
<h3 id="简单介绍一下-Linux-文件系统"><a href="#简单介绍一下-Linux-文件系统" class="headerlink" title="简单介绍一下 Linux 文件系统"></a>简单介绍一下 Linux 文件系统</h3><h4 id="Linux文件系统简介"><a href="#Linux文件系统简介" class="headerlink" title="Linux文件系统简介"></a>Linux文件系统简介</h4><p>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 </p>
<p>也就是说在 LINUX 系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而 Linux 是重写 UNIX 而来，所以这个概念也就传承了下来。在 UNIX 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>
<h5 id="文件类型与目录结构"><a href="#文件类型与目录结构" class="headerlink" title="文件类型与目录结构"></a>文件类型与目录结构</h5><h6 id="Linux支持5种文件类型"><a href="#Linux支持5种文件类型" class="headerlink" title="Linux支持5种文件类型"></a>Linux支持5种文件类型</h6><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux.jpg" class="" title="Linux支持5种文件类型">

<h6 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h6><img src="/2020/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98/root.jpg" class="" title="Linux的目录结构">

<p>常见目录说明：</p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里。</li>
<li><strong>/etc：</strong> 存放系统管理和配置文件。</li>
<li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序。</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</li>
<li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</li>
<li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级）。</li>
<li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序，如ifconfig等。</li>
<li><strong>/dev：</strong> 用于存放设备文件。</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</li>
<li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件。</li>
<li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 。</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点。</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志）等。</li>
<li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫 .chk）就在这里。</li>
</ul>
<hr>
<h3 id="一些常见的-Linux-命令"><a href="#一些常见的-Linux-命令" class="headerlink" title="一些常见的 Linux 命令"></a>一些常见的 Linux 命令</h3><h4 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h4><ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下usr目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h4 id="目录的操作命令（增删改查）"><a href="#目录的操作命令（增删改查）" class="headerlink" title="目录的操作命令（增删改查）"></a>目录的操作命令（增删改查）</h4><ul>
<li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p>
</li>
<li><p><strong><code>ls或者ll</code></strong>（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p>
</li>
<li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p>
</li>
<li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p>
<p>注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</p>
</li>
<li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）</p>
<p>注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</p>
</li>
<li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝</p>
<p>注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写 -r 递归。</p>
</li>
<li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p>
<p>注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用 <code>rm -rf</code> 目录/文件/压缩包。</p>
</li>
</ul>
<h4 id="文件的操作命令（增删改查）"><a href="#文件的操作命令（增删改查）" class="headerlink" title="文件的操作命令（增删改查）"></a>文件的操作命令（增删改查）</h4><ul>
<li><p><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）</p>
</li>
<li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p>
<ul>
<li><strong><code>cat</code>：</strong> 查看显示文件内容</li>
<li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q 可以退出查看</li>
<li><strong><code>less</code>：</strong> 可以使用键盘上的 PgUp 和 PgDn 向上 和向下翻页，q 结束查看</li>
<li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C 结束</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 tail -f catalina-2016-11-11.log 监控文件的变化。</p>
</li>
<li><p><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）</p>
<p>vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。</p>
</li>
</ul>
<p>  在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</p>
<ol>
<li>vim 文件</li>
<li>进入文件</li>
<li>命令模式</li>
<li>按i进入编辑模式</li>
<li>编辑文件</li>
<li>按Esc进入底行模式</li>
<li>输入：wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q! 代表强制退出不保存。）</li>
</ol>
<ul>
<li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p>
<p>同目录删除：熟记 <code>rm -rf</code> 文件 即可</p>
</li>
</ul>
<h4 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h4><h5 id="打包并压缩文件"><a href="#打包并压缩文件" class="headerlink" title="打包并压缩文件"></a>打包并压缩文件</h5><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong> 其中：</p>
<p>z：调用gzip压缩命令进行压缩</p>
<p>c：打包文件</p>
<p>v：显示运行过程</p>
<p>f：指定文件名</p>
<p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz /test/</code></strong></p>
<h5 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h5><p>命令：tar [-xvf] 压缩文件</p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p>
<h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><strong><code>sudo + 其他命令</code></strong>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
</li>
<li><p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><p><strong>net-tools 和 iproute2 ：</strong> <code>net-tools</code>起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持<code>iproute2</code>。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener">如何在Linux中使用IP命令和示例</a></p>
</li>
<li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/05/02/Nginx%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" rel="next" title="Nginx快速入门">
      Nginx快速入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">1.1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的特征"><span class="nav-number">1.1.1.</span> <span class="nav-text">面向对象的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多态的三个必要条件"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">多态的三个必要条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多态的优点"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">多态的优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">抽象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载和重写的区别"><span class="nav-number">1.1.2.</span> <span class="nav-text">重载和重写的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载-Overload"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">重载  Overload</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重写-Override"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">重写  Override</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类和接口的区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">抽象类和接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于final关键字"><span class="nav-number">1.1.4.</span> <span class="nav-text">关于final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuffer-和-StringBuilder-的区别"><span class="nav-number">1.1.5.</span> <span class="nav-text">String、StringBuffer 和 StringBuilder 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-与-的区别"><span class="nav-number">1.1.6.</span> <span class="nav-text">equals 与 &#x3D;&#x3D; 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">equals()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java异常"><span class="nav-number">1.1.7.</span> <span class="nav-text">Java异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Error（错误）"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">Error（错误）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception（异常）"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">Exception（异常）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一般异常"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">一般异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#运行时异常"><span class="nav-number">1.1.7.2.2.</span> <span class="nav-text">运行时异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键字"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">关键字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java集合框架"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-和-Set"><span class="nav-number">1.2.1.</span> <span class="nav-text">List 和 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Arraylist、Vector-与-LinkedList"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Arraylist、Vector 与 LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#list-的遍历方式选择"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">list 的遍历方式选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet-和-HashMap"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">HashSet 和 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet如何检查重复"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">HashSet如何检查重复</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">1.3.</span> <span class="nav-text">Java虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存区域"><span class="nav-number">1.3.1.</span> <span class="nav-text">Java内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本问题"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">基本问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾回收"><span class="nav-number">1.3.2.</span> <span class="nav-text">JVM垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本问题-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">基本问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路线索"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">思路线索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何判断对象是否死亡"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">如何判断对象是否死亡</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#各层结构与作用"><span class="nav-number">2.1.</span> <span class="nav-text">各层结构与作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP、UDP-协议的区别"><span class="nav-number">2.2.</span> <span class="nav-text">TCP、UDP 协议的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url-地址到显示网页的过程"><span class="nav-number">2.3.</span> <span class="nav-text">url 地址到显示网页的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-三次握手和四次挥手"><span class="nav-number">2.4.</span> <span class="nav-text">TCP 三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手"><span class="nav-number">2.4.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要三次握手"><span class="nav-number">2.4.2.</span> <span class="nav-text">为什么要三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要传回-SYN"><span class="nav-number">2.4.3.</span> <span class="nav-text">为什么要传回 SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传了-SYN-为什么还要传-ACK"><span class="nav-number">2.4.4.</span> <span class="nav-text">传了 SYN,为什么还要传 ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四次挥手"><span class="nav-number">2.4.5.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要四次挥手"><span class="nav-number">2.4.6.</span> <span class="nav-text">为什么要四次挥手</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">3.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">3.1.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单介绍一下-Linux-文件系统"><span class="nav-number">3.1.1.</span> <span class="nav-text">简单介绍一下 Linux 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux文件系统简介"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Linux文件系统简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件类型与目录结构"><span class="nav-number">3.1.1.1.1.</span> <span class="nav-text">文件类型与目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Linux支持5种文件类型"><span class="nav-number">3.1.1.1.1.1.</span> <span class="nav-text">Linux支持5种文件类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Linux的目录结构"><span class="nav-number">3.1.1.1.1.2.</span> <span class="nav-text">Linux的目录结构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些常见的-Linux-命令"><span class="nav-number">3.1.2.</span> <span class="nav-text">一些常见的 Linux 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目录切换命令"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">目录切换命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录的操作命令（增删改查）"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">目录的操作命令（增删改查）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的操作命令（增删改查）"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">文件的操作命令（增删改查）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩文件的操作命令"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">压缩文件的操作命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#打包并压缩文件"><span class="nav-number">3.1.2.4.1.</span> <span class="nav-text">打包并压缩文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解压压缩包"><span class="nav-number">3.1.2.4.2.</span> <span class="nav-text">解压压缩包</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他常用命令"><span class="nav-number">3.1.2.5.</span> <span class="nav-text">其他常用命令</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liuby"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">liuby</p>
  <div class="site-description" itemprop="description">操千曲而后晓声，观千剑而后识器。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuby01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuby01" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liuby01@outlook.com" title="E-Mail → mailto:liuby01@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3221756052" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3221756052" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">Stack Overflow</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://segmentfault.com/" title="https:&#x2F;&#x2F;segmentfault.com&#x2F;" rel="noopener" target="_blank">SegmentFault</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;" rel="noopener" target="_blank">LeetCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">V2EX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://juejin.im/" title="https:&#x2F;&#x2F;juejin.im&#x2F;" rel="noopener" target="_blank">掘金</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuby</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
